from typing import Any, Callable, IO, List, Optional, Set, Tuple
from enum import IntEnum

class Matches(IntEnum): ...

def dump(obj: Any, fp: IO[str], *args: Any, **kw: Any) -> None: ...
def dumps(obj: Any, *args: Any, **kw: Any) -> str: ...
def matches_all(*enums: Matches) -> bool: ...
def matches_any(*enums: Matches) -> bool: ...
def matches(left, right, ctx: Optional[Set[Any]] = None): ...
@functools.singledispatch
def is_ambiguous(
    pattern, threshold: Matches = Matches.always, _path=()
) -> Tuple[str]: ...
@is_ambiguous.register(Atom)
@is_ambiguous.register(String)
def _(pattern, threshold: Matches = Matches.always, _path=()) -> Tuple[str]: ...

class Atom:
    def __init__(self, value) -> None: ...
    def _matches(self, other, ctx) -> Matches: ...

class String:
    def __init__(self, name, arg=None) -> None: ...
    @classmethod
    def exact(cls, string: str): ...
    def _matches(self, other: String, ctx) -> Matches: ...

class _Unknown:
    def __init__(self, name, match) -> None: ...

class Alternatives:
    def __init__(self, alts) -> None: ...
    def for_json(self) -> List[str]: ...

class Array:
    def __init__(self, elems, *, homog) -> None: ...
    def _matches(self, other: Array, ctx): ...
    def for_json(self) -> List[Any]: ...

class Object:
    def __init__(self, items, *, homog) -> None: ...
    def _matches(self, other: Object, ctx): ...
