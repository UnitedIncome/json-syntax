import typing as t

logger: logging.Logger = ...
NoneType: t.Type[None] = ...
python_minor: t.Tuple[int, int] = ...
JSON2PY: str = ...
PY2JSON: str = ...
INSP_JSON: str = ...
INSP_PY: str = ...
PATTERN: str = ...
SENTINEL: object = ...

def _eval_type(typ: type, namespace: t.Any, dict) -> type: ...

_map: t.List[
    Tuple[
        t.Union[t.TypeAlias, t._SpecialForm],
        t.Union[
            Callable(callable)[[object], bool],
            Callable(type.__call__)[[Variable(t.Any), Keywords(t.Any)], t.Any],
        ],
    ]
] = ...
seen: t.Set[t.Union[t.TypeAlias, t._SpecialForm]] = ...
_pts: t.Dict[
    t.Union[t.TypeAlias, t._SpecialForm],
    t.Union[
        Callable(callable)[[object], bool],
        Callable(type.__call__)[[Variable(t.Any), Keywords(t.Any)], t.Any],
    ],
] = ...
_stp: t.Dict[
    t.Union[
        Callable(callable)[[object], bool],
        Callable(type.__call__)[[Variable(t.Any), Keywords(t.Any)], t.Any],
    ],
    t.Union[t.TypeAlias, t._SpecialForm],
] = ...
_missing_values: t.Set[t.Any] = ...

def has_origin(typ: type, origin: type, num_args: t.Optional[int] = None) -> bool: ...
def is_generic(typ: type) -> bool: ...
def issub_safe(sub: type, sup: type) -> bool: ...
def _add_context(context, exc) -> None: ...

class ErrorContext:
    def __init__(self, context) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

_T = t.TypeVar("_T")

def identity(value: _T) -> _T: ...
