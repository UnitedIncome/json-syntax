import pytest
from unittest.mock import Mock

from json_syntax import std
from json_syntax.helpers import JPI, J2P, P2J, IP, IJ, NoneType

from datetime import datetime, date
from enum import Enum, IntEnum
from functools import partial
from typing import Optional, Union, Tuple, List, Set, FrozenSet
from pickle import dumps


def Fail():
    return Mock(lookup_inner=Mock(side_effect=RuntimeError))


Mystery = Tuple["Mystery", "Thing"]


def test_atoms_disregard():
    "Test the atoms rule will disregard unknown types and verbs."

    assert std.atoms(verb="unknown", typ=str, ctx=Fail()) is None
    for verb in JPI:
        assert std.atoms(verb=verb, typ=Mystery, ctx=Fail()) is None


def test_atoms_str():
    "Test the atoms rule will generate encoders and decoders for strings."

    decoder = std.atoms(verb=J2P, typ=str, ctx=Fail())
    assert decoder("some string") == "some string"

    encoder = std.atoms(verb=P2J, typ=str, ctx=Fail())
    assert encoder("some string") == "some string"

    inspect = std.atoms(verb=IP, typ=str, ctx=Fail())
    assert inspect("string")
    assert not inspect(5)

    inspect = std.atoms(verb=IJ, typ=str, ctx=Fail())
    assert inspect("string")
    assert not inspect(5)


def test_atoms_int():
    "Test the atoms rule will generate encoders and decoders for integers."

    decoder = std.atoms(verb=J2P, typ=int, ctx=Fail())
    assert decoder(77) == 77

    encoder = std.atoms(verb=P2J, typ=int, ctx=Fail())
    assert encoder(77) == 77

    inspect = std.atoms(verb=IP, typ=int, ctx=Fail())
    assert not inspect("string")
    assert inspect(5)

    inspect = std.atoms(verb=IJ, typ=int, ctx=Fail())
    assert not inspect("string")
    assert inspect(5)


def test_atoms_bool():
    "Test the atoms rule will generate encoders and decoders for booleans."

    decoder = std.atoms(verb=J2P, typ=bool, ctx=Fail())
    assert decoder(False) is False
    assert decoder(True) is True

    encoder = std.atoms(verb=P2J, typ=bool, ctx=Fail())
    assert encoder(False) is False
    assert encoder(True) is True

    inspect = std.atoms(verb=IP, typ=bool, ctx=Fail())
    assert not inspect("string")
    assert inspect(True)

    inspect = std.atoms(verb=IJ, typ=bool, ctx=Fail())
    assert not inspect("string")
    assert inspect(False)


def test_atoms_float():
    "Test the atoms rule will generate encoders and decoders for floats that are tolerant of integers."

    decoder = std.atoms(verb=J2P, typ=float, ctx=Fail())
    assert decoder(77.7) == 77.7
    assert decoder(77) == 77.0

    encoder = std.atoms(verb=P2J, typ=float, ctx=Fail())
    assert encoder(77.7) == 77.7


def test_atoms_null():
    "Test the atoms rule will generate encoders and decoders for None / null."

    decoder = std.atoms(verb=J2P, typ=NoneType, ctx=Fail())
    assert decoder(None) is None

    encoder = std.atoms(verb=P2J, typ=NoneType, ctx=Fail())
    assert encoder(None) is None


def test_atoms_picklable():
    "Test that actions generated by the atoms rule can be pickled."

    actions = [
        std.atoms(verb=verb, typ=typ, ctx=Fail())
        for verb in [J2P, P2J]
        for typ in [str, float, int, bool, NoneType]
    ]
    assert None not in actions
    dumps(actions)


def test_iso_dates_disregard():
    "Test the iso_dates rule will disregard unknown types and verbs."

    assert std.iso_dates(verb="unknown", typ=date, ctx=Fail()) is None
    assert std.iso_dates(verb=J2P, typ=Mystery, ctx=Fail()) is None
    assert std.iso_dates(verb=P2J, typ=Mystery, ctx=Fail()) is None


def test_iso_dates():
    "Test the iso_dates rule will generate encoders and decoders for dates using ISO8601, accepting datetimes as input."

    decoder = std.iso_dates(verb=J2P, typ=date, ctx=Fail())
    assert decoder("1776-07-04") == date(1776, 7, 4)
    assert decoder("6543-02-01T09:09:09") == date(6543, 2, 1)

    encoder = std.iso_dates(verb=P2J, typ=date, ctx=Fail())
    assert encoder(date(1776, 7, 4)) == "1776-07-04"


def test_iso_dates_strict():
    "Test the iso_dates_strict rule will generate encoders and decoders for dates using ISO8601, rejecting datetimes as input to dates."

    decoder = std.iso_dates(verb=J2P, typ=date, ctx=Fail())
    assert decoder("1776-07-04") == date(1776, 7, 4)
    assert decoder("6543-02-01T09:09:09") == date(6543, 2, 1)

    encoder = std.iso_dates(verb=P2J, typ=date, ctx=Fail())
    assert encoder(date(1776, 7, 4)) == "1776-07-04"


def test_iso_datetimes():
    "Test the iso_dates rule will generate encoders and decoders for datetimes using ISO8601."

    decoder = std.iso_dates(verb=J2P, typ=datetime, ctx=Fail())
    assert decoder("6666-06-06T12:12:12.987654") == datetime(
        6666, 6, 6, 12, 12, 12, 987654
    )

    encoder = std.iso_dates(verb=P2J, typ=datetime, ctx=Fail())
    assert (
        encoder(datetime(6666, 6, 6, 12, 12, 12, 987654))
        == "6666-06-06T12:12:12.987654"
    )


def test_iso_dates_picklable():
    "Test that actions generated by the iso_dates rule can be pickled."

    actions = [
        std.iso_dates(verb=verb, typ=typ, ctx=Fail())
        for verb in [J2P, P2J]
        for typ in [date, datetime]
    ]
    assert None not in actions
    dumps(actions)


class Enum1(Enum):
    ABLE = "a"
    BAKER = "b"
    CHARLIE = "c"


def test_enums_disregard():
    "Test the iso_dates rule will disregard unknown types and verbs."

    assert std.enums(verb="unknown", typ=Enum1, ctx=Fail()) is None
    assert std.enums(verb=J2P, typ=Mystery, ctx=Fail()) is None
    assert std.enums(verb=P2J, typ=Mystery, ctx=Fail()) is None


def test_enums():
    "Test the enums rule will generate encoders and decoders for enumerated types."

    decoder = std.enums(verb=J2P, typ=Enum1, ctx=Fail())
    assert decoder("ABLE") == Enum1.ABLE
    assert decoder("CHARLIE") == Enum1.CHARLIE

    encoder = std.enums(verb=P2J, typ=Enum1, ctx=Fail())
    assert encoder(Enum1.BAKER) == "BAKER"
    assert encoder(Enum1.CHARLIE) == "CHARLIE"


class Enum2(IntEnum):
    ALPHA = 1
    BETA = 2
    GAMMA = 3


def test_enums_int():
    "Test the enums rule will generate encoders and decoders for enumerated type subclasses."
    decoder = std.enums(verb=J2P, typ=Enum2, ctx=Fail())
    assert decoder("ALPHA") == Enum2.ALPHA
    assert decoder("GAMMA") == Enum2.GAMMA

    encoder = std.enums(verb=P2J, typ=Enum2, ctx=Fail())
    assert encoder(Enum2.BETA) == "BETA"
    assert encoder(Enum2.GAMMA) == "GAMMA"


def test_enums_picklable():
    "Test that actions generated by the enums rule can be pickled."

    actions = [
        std.enums(verb=verb, typ=typ, ctx=Fail())
        for verb in [J2P, P2J]
        for typ in [Enum1, Enum2]
    ]
    assert None not in actions
    dumps(actions)


def test_optional_disregard():
    "Test that optional will disregard unknown types and verbs."

    assert std.optional(verb="unknown", typ=Optional[int], ctx=Fail()) is None
    assert std.optional(verb=J2P, typ=Union[int, str, NoneType], ctx=Fail()) is None
    assert std.optional(verb=J2P, typ=Mystery, ctx=Fail()) is None
    assert std.optional(verb=P2J, typ=Mystery, ctx=Fail()) is None


def test_optional():
    "Test that optional returns a action that pass non-null values to an inner action."

    ctx = Mock(lookup_inner=Mock(return_value=int))

    encoder = std.optional(verb=P2J, typ=Optional[int], ctx=ctx)
    assert encoder("77") == 77
    assert encoder(None) is None

    decoder = std.optional(verb=J2P, typ=Optional[int], ctx=ctx)
    assert decoder("77") == 77
    assert decoder(None) is None


def test_optional_nonstandard():
    "Test that optional recognizes Unions that are effectively Optional."

    ctx = Mock(lookup_inner=Mock(return_value=str))

    encoder = std.optional(verb=P2J, typ=Union[str, NoneType], ctx=ctx)
    assert encoder(77) == "77"
    assert encoder(None) is None

    decoder = std.optional(verb=J2P, typ=Union[str, NoneType], ctx=ctx)
    assert decoder(77) == "77"
    assert decoder(None) is None


def test_optional_invalid():
    "Test that optional raises if no valid inner type is found."

    ctx = Mock(lookup_inner=Mock(return_value=str))
    fake_type = Mock(__origin__=Union, __args__=(NoneType, NoneType))

    with pytest.raises(TypeError):
        std.optional(verb=P2J, typ=fake_type, ctx=ctx)

    with pytest.raises(TypeError):
        std.optional(verb=J2P, typ=fake_type, ctx=ctx)


def test_optional_picklable():
    "Test that actions generated by the optional rule can be pickled."

    ctx = Mock(lookup_inner=partial(std.atoms, ctx=Fail()))

    actions = [
        std.optional(verb=verb, typ=typ, ctx=ctx)
        for verb in [J2P, P2J]
        for typ in [Optional[str], Optional[float], Optional[int], Optional[bool]]
    ]
    assert None not in actions
    dumps(actions)


def test_lists_disregards():
    "Test that lists disregards unknown types and verbs."

    assert std.lists(verb="unknown", typ=List[int], ctx=Fail()) is None
    assert std.lists(verb="unknown", typ=Tuple[int, ...], ctx=Fail()) is None
    assert std.lists(verb=P2J, typ=bool, ctx=Fail()) is None
    assert std.lists(verb=J2P, typ=Tuple[int, str], ctx=Fail()) is None


def test_lists_lists():
    "Test that lists will generate encoders and decoders for lists."

    ctx = Mock(lookup_inner=Mock(return_value=str))

    encoder = std.lists(verb=P2J, typ=List[str], ctx=ctx)
    assert encoder([33, 77]) == ["33", "77"]

    decoder = std.lists(verb=J2P, typ=List[str], ctx=ctx)
    assert decoder([33, 77]) == ["33", "77"]


def test_lists_tuples():
    "Test that lists will generate encoders and decoders for homogenous tuples."

    ctx = Mock(lookup_inner=Mock(return_value=str))

    encoder = std.lists(verb=P2J, typ=Tuple[str, ...], ctx=ctx)
    assert encoder((33, 77)) == ["33", "77"]

    decoder = std.lists(verb=J2P, typ=Tuple[str, ...], ctx=ctx)
    assert decoder([33, 77]) == ("33", "77")

    # Prove these tests don't pass spuriously.
    assert ["1", "2"] != ("1", "2")


def test_sets_disregards():
    "Test that sets disregards unknown types and verbs."

    assert std.sets(verb="unknown", typ=Set[int], ctx=Fail()) is None
    assert std.sets(verb="unknown", typ=FrozenSet[set], ctx=Fail()) is None
    assert std.sets(verb=P2J, typ=bool, ctx=Fail()) is None
    assert std.sets(verb=J2P, typ=List[str], ctx=Fail()) is None


def test_sets_sets():
    "Test that sets will generate encoders and decoders for sets."

    ctx = Mock(lookup_inner=Mock(return_value=str))

    encoder = std.sets(verb=P2J, typ=Set[str], ctx=ctx)
    actual = encoder({1, 2, 2, 3})
    actual.sort()
    assert actual == ["1", "2", "3"]

    decoder = std.sets(verb=J2P, typ=Set[str], ctx=ctx)
    assert decoder([1, 2, 2, 3]) == {"1", "2", "3"}


def test_sets_frozen():
    "Test that sets will generate encoders and decoders for frozen sets."

    ctx = Mock(lookup_inner=Mock(return_value=str))

    encoder = std.sets(verb=P2J, typ=FrozenSet[str], ctx=ctx)
    actual = encoder(frozenset([1, 2, 2, 3]))
    actual.sort()
    assert actual == ["1", "2", "3"]

    decoder = std.sets(verb=J2P, typ=FrozenSet[str], ctx=ctx)
    assert decoder([1, 2, 2, 3]) == frozenset(["1", "2", "3"])
